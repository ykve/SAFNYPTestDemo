// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: state.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "State.pbobjc.h"
#import "Error.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - StateRoot

@implementation StateRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - StateRoot_FileDescriptor

static GPBFileDescriptor *StateRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"fpb"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum State

GPBEnumDescriptor *State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Offline\000Online\000Background\000";
    static const int32_t values[] = {
        State_Offline,
        State_Online,
        State_Background,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL State_IsValidValue(int32_t value__) {
  switch (value__) {
    case State_Offline:
    case State_Online:
    case State_Background:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserState

@implementation UserState

@dynamic userId;
@dynamic state;
@dynamic offlineTime;

typedef struct UserState__storage_ {
  uint32_t _has_storage_[1];
  State state;
  uint64_t userId;
  int64_t offlineTime;
} UserState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserState_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserState__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = State_EnumDescriptor,
        .number = UserState_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserState__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "offlineTime",
        .dataTypeSpecific.className = NULL,
        .number = UserState_FieldNumber_OfflineTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserState__storage_, offlineTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserState class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserState_State_RawValue(UserState *message) {
  GPBDescriptor *descriptor = [UserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserState_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserState_State_RawValue(UserState *message, int32_t value) {
  GPBDescriptor *descriptor = [UserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserState_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CStateUser

@implementation CStateUser

@dynamic userIdArray, userIdArray_Count;

typedef struct CStateUser__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *userIdArray;
} CStateUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdArray",
        .dataTypeSpecific.className = NULL,
        .number = CStateUser_FieldNumber_UserIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CStateUser__storage_, userIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CStateUser class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CStateUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SStateUser

@implementation SStateUser

@dynamic result;
@dynamic userStateArray, userStateArray_Count;

typedef struct SStateUser__storage_ {
  uint32_t _has_storage_[1];
  Error result;
  NSMutableArray *userStateArray;
} SStateUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = Error_EnumDescriptor,
        .number = SStateUser_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SStateUser__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userStateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserState),
        .number = SStateUser_FieldNumber_UserStateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SStateUser__storage_, userStateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SStateUser class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SStateUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SStateUser_Result_RawValue(SStateUser *message) {
  GPBDescriptor *descriptor = [SStateUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SStateUser_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSStateUser_Result_RawValue(SStateUser *message, int32_t value) {
  GPBDescriptor *descriptor = [SStateUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SStateUser_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CSetUserState

@implementation CSetUserState

@dynamic state;

typedef struct CSetUserState__storage_ {
  uint32_t _has_storage_[1];
  State state;
} CSetUserState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = State_EnumDescriptor,
        .number = CSetUserState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CSetUserState__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CSetUserState class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CSetUserState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CSetUserState_State_RawValue(CSetUserState *message) {
  GPBDescriptor *descriptor = [CSetUserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CSetUserState_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetCSetUserState_State_RawValue(CSetUserState *message, int32_t value) {
  GPBDescriptor *descriptor = [CSetUserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CSetUserState_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SSetUserState

@implementation SSetUserState

@dynamic result;

typedef struct SSetUserState__storage_ {
  uint32_t _has_storage_[1];
  Error result;
} SSetUserState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = Error_EnumDescriptor,
        .number = SSetUserState_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SSetUserState__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SSetUserState class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SSetUserState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SSetUserState_Result_RawValue(SSetUserState *message) {
  GPBDescriptor *descriptor = [SSetUserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SSetUserState_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetSSetUserState_Result_RawValue(SSetUserState *message, int32_t value) {
  GPBDescriptor *descriptor = [SSetUserState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SSetUserState_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SNotifyStateChange

@implementation SNotifyStateChange

@dynamic userStateArray, userStateArray_Count;

typedef struct SNotifyStateChange__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userStateArray;
} SNotifyStateChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userStateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserState),
        .number = SNotifyStateChange_FieldNumber_UserStateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SNotifyStateChange__storage_, userStateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SNotifyStateChange class]
                                     rootClass:[StateRoot class]
                                          file:StateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SNotifyStateChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
